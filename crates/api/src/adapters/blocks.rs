//! Type adapters for block building commands
//!
//! Provides conversion utilities between domain types (ProposedBlock) and
//! legacy database types (PrismaTimeEntryDto) during Phase 4B.1 migration.
//!
//! # Purpose
//!
//! This adapter layer enables the new hexagonal architecture commands to
//! interface with legacy database schemas and frontend expectations without
//! requiring immediate breaking changes across the entire stack.
//!
//! # Migration Status
//!
//! - Phase 4B.1: Active (block commands migration)

use chrono::{DateTime, Utc};
use pulsearc_domain::types::classification::{ActivityBreakdown, ProposedBlock};
use pulsearc_domain::types::database::PrismaTimeEntryDto;
use serde::Serialize;
use thiserror::Error;
use {blake3, hex};

/// Adapter-specific error type covering recoverable failures.
#[derive(Debug, Error, Serialize)]
pub enum BlockAdapterError {
    /// Provided timestamp could not be represented as a UTC datetime.
    #[error("invalid timestamp: {timestamp}")]
    InvalidTimestamp { timestamp: i64 },

    /// Duration could not be represented in legacy schema widths.
    #[error("duration overflow for {field}: {duration_secs} seconds cannot be represented")]
    DurationOverflow { field: &'static str, duration_secs: i64 },
}

/// Convert a ProposedBlock to PrismaTimeEntryDto for outbox persistence
///
/// Maps classification results from the domain model to the legacy Prisma
/// schema format expected by the SAP/backend sync layer.
///
/// # Arguments
///
/// * `block` - Domain-level proposed time block with classification metadata
/// * `user_id` - Authenticated user identifier
/// * `org_id` - Organization identifier for multi-tenant context
///
/// # Returns
///
/// Result containing PrismaTimeEntryDto ready for serialization and SAP
/// forwarding
///
/// # Field Mapping
///
/// - `project_id` ← `inferred_project_id` (fallback: "unknown_project")
/// - `wbs_code` ← `inferred_wbs_code`
/// - `entry_date` ← `start_ts` formatted as "YYYY-MM-DD"
/// - `duration_minutes` ← `duration_secs / 60`
/// - `duration_sec` ← `duration_secs` (for legacy compatibility)
/// - `billable` ← block classification result
/// - `confidence` ← classification confidence score
/// - `notes` ← Generated from `inferred_deal_name`
/// - `source` ← "block_builder" (identifies origin)
/// - `status` ← "draft" (pending SAP submission)
pub fn block_to_time_entry_dto(
    block: &ProposedBlock,
    user_id: &str,
    org_id: &str,
) -> Result<PrismaTimeEntryDto, BlockAdapterError> {
    let duration_minutes = to_legacy_minutes(block.duration_secs)?;
    let duration_seconds = to_i32_duration("duration_sec", block.duration_secs)?;
    let context_breakdown = map_activities_to_context_parts(&block.activities)?;

    Ok(PrismaTimeEntryDto {
        id: None, // Generated by backend
        org_id: org_id.to_string(),
        project_id: block
            .inferred_project_id
            .clone()
            .unwrap_or_else(|| "unknown_project".to_string()),
        task_id: None,
        user_id: user_id.to_string(),
        entry_date: format_entry_date(block.start_ts)?,
        duration_minutes,
        notes: Some(format!(
            "Block builder: {}",
            block.inferred_deal_name.clone().unwrap_or_else(|| "Unknown".to_string())
        )),
        billable: Some(block.billable),
        source: "block_builder".to_string(),
        status: Some("draft".to_string()),
        start_time: None,
        end_time: None,
        duration_sec: Some(duration_seconds),
        wbs_code: block.inferred_wbs_code.clone(),
        display_project: block.inferred_deal_name.clone(),
        display_workstream: block.inferred_workstream.clone(),
        display_task: None,
        confidence: Some(block.confidence),
        context_breakdown: Some(context_breakdown),
    })
}

/// Generate a deterministic, collision-resistant idempotency key for outbox
/// entries
///
/// Combines:
/// - Block identifier (client-provided unique ID)
/// - User identifier (multi-tenant isolation)
/// - Block start timestamp (temporal uniqueness)
/// - Blake3 hash prefix of the concatenated metadata (content-based uniqueness)
///
/// # Format
///
/// ```text
/// {block_id}:{user_id}:{start_ts}:{blake3_prefix}
/// ```
///
/// # Example
///
/// ```text
/// block-123:user_abc123:1698163200:a1b2c3d4e5f6g7h8
/// ```
///
/// # Arguments
///
/// * `block_id` - Unique block identifier
/// * `user_id` - User owning this time entry
/// * `start_ts` - Block start timestamp (Unix epoch seconds)
///
/// # Returns
///
/// Idempotency key suitable for duplicate detection in distributed systems
///
/// # Security
///
/// - Blake3 provides 256-bit collision resistance
/// - First 8 bytes (16 hex chars) give 2^64 hash space
/// - Deterministic output ensures duplicate detection across retries
pub fn generate_idempotency_key(block_id: &str, user_id: &str, start_ts: i64) -> String {
    let data = format!("{}:{}:{}", block_id, user_id, start_ts);
    let hash = blake3::hash(data.as_bytes());

    format!(
        "{}:{}:{}:{}",
        block_id,
        user_id,
        start_ts,
        hex::encode(&hash.as_bytes()[..8]) // 64-bit hash prefix
    )
}

/// Format Unix timestamp to ISO 8601 date string for Prisma schema
///
/// Converts epoch seconds to "YYYY-MM-DD" format required by backend API.
///
/// # Arguments
///
/// * `timestamp` - Unix epoch seconds
///
/// # Returns
///
/// ISO 8601 date string (e.g., "2024-10-31")
///
/// # Errors
///
/// Returns `BlockAdapterError::InvalidTimestamp` when the supplied timestamp
/// cannot be represented as a UTC datetime.
fn format_entry_date(timestamp: i64) -> Result<String, BlockAdapterError> {
    DateTime::<Utc>::from_timestamp(timestamp, 0)
        .map(|dt| dt.date_naive().format("%Y-%m-%d").to_string())
        .ok_or(BlockAdapterError::InvalidTimestamp { timestamp })
}

/// Map domain ActivityBreakdown to legacy ContextPart format
///
/// Converts new domain types to frontend-compatible JSON structure.
///
/// # Arguments
///
/// * `activities` - Activity breakdown from block classification
///
/// # Returns
///
/// Vector of ContextPart DTOs for legacy frontend
fn map_activities_to_context_parts(
    activities: &[ActivityBreakdown],
) -> Result<Vec<pulsearc_domain::types::database::ContextPart>, BlockAdapterError> {
    activities
        .iter()
        .map(|activity| {
            let duration_sec =
                to_i32_duration("context_breakdown.duration_sec", activity.duration_secs)?;

            Ok(pulsearc_domain::types::database::ContextPart {
                app: activity.name.clone(),
                duration_sec,
                contribution: activity.percentage,
            })
        })
        .collect()
}

fn to_i32_duration(field: &'static str, duration_secs: i64) -> Result<i32, BlockAdapterError> {
    i32::try_from(duration_secs)
        .map_err(|_| BlockAdapterError::DurationOverflow { field, duration_secs })
}

fn to_legacy_minutes(duration_secs: i64) -> Result<i32, BlockAdapterError> {
    let minutes = duration_secs
        .checked_div(60)
        .ok_or(BlockAdapterError::DurationOverflow { field: "duration_minutes", duration_secs })?;

    i32::try_from(minutes).map_err(|_| BlockAdapterError::DurationOverflow {
        field: "duration_minutes",
        duration_secs,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_idempotency_key_format() {
        let key = generate_idempotency_key("block-123", "user-456", 1698163200);

        // Should have 4 colon-separated parts
        let parts: Vec<&str> = key.split(':').collect();
        assert_eq!(parts.len(), 4, "Idempotency key should have 4 parts");

        assert_eq!(parts[0], "block-123");
        assert_eq!(parts[1], "user-456");
        assert_eq!(parts[2], "1698163200");
        assert_eq!(parts[3].len(), 16, "Hash should be 16 hex characters");
    }

    #[test]
    fn test_idempotency_key_deterministic() {
        // Same inputs should produce identical keys
        let key1 = generate_idempotency_key("block-1", "user-1", 1698163200);
        let key2 = generate_idempotency_key("block-1", "user-1", 1698163200);
        assert_eq!(key1, key2, "Same inputs should produce identical keys");

        // Different inputs must alter the key
        let different_block = generate_idempotency_key("block-2", "user-1", 1698163200);
        assert_ne!(key1, different_block, "Different block IDs should change the key");
    }

    #[test]
    fn test_format_entry_date() {
        // Test known timestamp: 2024-10-24 00:00:00 UTC
        let timestamp = 1729728000;
        let date = format_entry_date(timestamp).expect("timestamp should be valid");
        assert_eq!(date, "2024-10-24");
    }

    #[test]
    fn test_format_entry_date_rejects_invalid_timestamp() {
        let result = format_entry_date(i64::MAX);
        assert!(matches!(result, Err(BlockAdapterError::InvalidTimestamp { .. })));
    }

    #[test]
    fn test_block_to_time_entry_dto() {
        let block = ProposedBlock {
            id: "block-123".to_string(),
            start_ts: 1729728000,
            end_ts: 1729729800,
            duration_secs: 1800,
            inferred_project_id: Some("PRJ-001".to_string()),
            inferred_wbs_code: Some("WBS-001".to_string()),
            inferred_deal_name: Some("Project Atlas".to_string()),
            inferred_workstream: Some("Development".to_string()),
            billable: true,
            confidence: 0.92,
            classifier_used: None,
            activities: vec![ActivityBreakdown {
                name: "VSCode".to_string(),
                duration_secs: 1200,
                percentage: 66.7,
            }],
            snapshot_ids: vec![],
            segment_ids: vec![],
            reasons: vec![],
            status: "suggested".to_string(),
            created_at: 1729728000,
            reviewed_at: None,
            total_idle_secs: 0,
            idle_handling: "exclude".to_string(),
            timezone: None,
            work_location: None,
            is_travel: false,
            is_weekend: false,
            is_after_hours: false,
            has_calendar_overlap: false,
            overlapping_event_ids: vec![],
            is_double_booked: false,
        };

        let dto = block_to_time_entry_dto(&block, "user-123", "org-456")
            .expect("block should convert to Prisma DTO");

        assert_eq!(dto.user_id, "user-123");
        assert_eq!(dto.org_id, "org-456");
        assert_eq!(dto.project_id, "PRJ-001");
        assert_eq!(dto.wbs_code, Some("WBS-001".to_string()));
        assert_eq!(dto.entry_date, "2024-10-24");
        assert_eq!(dto.duration_minutes, 30); // 1800 / 60
        assert_eq!(dto.duration_sec, Some(1800));
        assert_eq!(dto.billable, Some(true));
        assert_eq!(dto.confidence, Some(0.92));
        assert_eq!(dto.source, "block_builder");
        assert_eq!(dto.status, Some("draft".to_string()));
        assert_eq!(dto.display_project, Some("Project Atlas".to_string()));
        assert_eq!(dto.display_workstream, Some("Development".to_string()));

        // Verify context breakdown mapping
        assert!(dto.context_breakdown.is_some());
        let context = dto.context_breakdown.unwrap();
        assert_eq!(context.len(), 1);
        assert_eq!(context[0].app, "VSCode");
        assert_eq!(context[0].duration_sec, 1200);
    }

    #[test]
    fn test_block_to_dto_with_missing_fields() {
        // Test that missing optional fields are handled gracefully
        let block = ProposedBlock {
            id: "block-456".to_string(),
            start_ts: 1729728000,
            end_ts: 1729729800,
            duration_secs: 1800,
            inferred_project_id: None, // Missing
            inferred_wbs_code: None,   // Missing
            inferred_deal_name: None,  // Missing
            inferred_workstream: None, // Missing
            billable: false,
            confidence: 0.0,
            classifier_used: None,
            activities: vec![],
            snapshot_ids: vec![],
            segment_ids: vec![],
            reasons: vec![],
            status: "pending_classification".to_string(),
            created_at: 1729728000,
            reviewed_at: None,
            total_idle_secs: 0,
            idle_handling: "exclude".to_string(),
            timezone: None,
            work_location: None,
            is_travel: false,
            is_weekend: false,
            is_after_hours: false,
            has_calendar_overlap: false,
            overlapping_event_ids: vec![],
            is_double_booked: false,
        };

        let dto = block_to_time_entry_dto(&block, "user-789", "org-999")
            .expect("block with minimal data should convert to Prisma DTO");

        // Should use fallback values
        assert_eq!(dto.project_id, "unknown_project");
        assert_eq!(dto.wbs_code, None);
        assert_eq!(dto.display_project, None);
        assert_eq!(dto.notes, Some("Block builder: Unknown".to_string()));
    }

    #[test]
    fn test_block_to_dto_rejects_large_duration() {
        let block = ProposedBlock {
            id: "block-overflow".to_string(),
            start_ts: 1729728000,
            end_ts: 1729731600,
            duration_secs: (i32::MAX as i64) + 1,
            inferred_project_id: Some("PRJ-001".to_string()),
            inferred_wbs_code: None,
            inferred_deal_name: None,
            inferred_workstream: None,
            billable: false,
            confidence: 0.0,
            classifier_used: None,
            activities: vec![],
            snapshot_ids: vec![],
            segment_ids: vec![],
            reasons: vec![],
            status: "pending_classification".to_string(),
            created_at: 1729728000,
            reviewed_at: None,
            total_idle_secs: 0,
            idle_handling: "exclude".to_string(),
            timezone: None,
            work_location: None,
            is_travel: false,
            is_weekend: false,
            is_after_hours: false,
            has_calendar_overlap: false,
            overlapping_event_ids: vec![],
            is_double_booked: false,
        };

        let result = block_to_time_entry_dto(&block, "user-1", "org-1");
        assert!(matches!(
            result,
            Err(BlockAdapterError::DurationOverflow { field: "duration_sec", .. })
        ));
    }
}
